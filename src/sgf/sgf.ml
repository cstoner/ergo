open OUnit;;
open SgfUtil;;

(****************************************************************************)
(* I should really move this file handling shit to another file... *)
(****************************************************************************)
let rec full_path_of_str str =
  let length = String.length str in
  let dir_name = Filename.dirname str in
    
    if (String.compare Filename.current_dir_name dir_name)=0 then
      ((Sys.getcwd()) ^ (String.sub str 1 length))
    else if (String.compare Filename.parent_dir_name dir_name)=0 then
      (Sys.getcwd() ^ "/" ^ str)
    else if (String.get str 0)='~' then
      (Sys.getenv("HOME") ^ (String.sub str 1 (length-1)))
    else  (* I need to add a 'search known directories' option here *)
      (Filename.dirname Sys.executable_name) ^ "/" ^ str
;;

let string_of_file filename =
  let full_filename = full_path_of_str filename in
  let rec build_string ichan accum=
    try
      let in_string = input_line ichan in
      let in_length = (String.length in_string)-1 in
	if (String.get in_string in_length = '\\') then
	  build_string ichan (accum ^ (String.sub in_string 0 (in_length-1)))
	else
	  build_string ichan (accum ^ in_string)
    with
	End_of_file -> accum
  in

  try 
    let ic = (open_in full_filename) in
    let raw_sgf=(build_string ic "") in
      close_in ic;
      raw_sgf;
  with
      Sys_error x -> print_string x; raise (Sys_error x)
;;

(*************************************************************
 * SGF Property handlers.
 * Follows the naming convention <PROPERTY_NAME>_prop args
*************************************************************)
exception Bad_Arg;;

(* "aa" is upper left corner *)
(* "cb" is the 2nd row down, 3rd column from the left *)
let pos_of_sgf_coord str_pos =
  let size = Board.size() in
  let col = (int_of_char (String.get str_pos 0)) - (int_of_char 'a') + 1 in
  let row = (int_of_char (String.get str_pos 1)) - (int_of_char 'a') + 1 in

    if String.compare str_pos "pass"=0 then Board.Pass
    else if (col >= size) or (row >= size) then raise Bad_Arg
    else
      Board.pos_of_coord (size-col, size-row)
;;


let gm_prop args =
  match args with
      [Number 1] -> ()
    | _ -> raise Bad_Arg
;;

let ff_prop args=
  match args with
      [Number 4] -> ()
    | _ -> raise Bad_Arg
;;

let sz_prop args=
  match args with
      [Number s] -> Board.boardsize s; Board.clear_board()
    | _ -> raise Bad_Arg
;;

(* Move properties *)

(***************
 * THIS USES SOME BAD CODE
 * Board.trymove should eventually be moved to a board.play function that is tidier with the game
***************)
let b_prop args=
  match args with
      [Move str_pos] -> Board.trymove Board.Black (pos_of_sgf_coord str_pos)
    | _ -> raise Bad_Arg
;;

let w_prop args=
  match args with
      [Move str_pos] -> Board.trymove Board.White (pos_of_sgf_coord str_pos)
    | _ -> raise Bad_Arg
;;

(* Setup properties *)

(* This is pretty dirty, too. I should make these operations undoable *)
let ab_prop args=
  match args with
      [Move str_pos] -> (Board.set_stones [(Board.Black, pos_of_sgf_coord str_pos)])
    | _ -> raise Bad_Arg
;;

let aw_prop args=
  match args with
      [Move str_pos] -> (Board.set_stones [(Board.White, pos_of_sgf_coord str_pos)])
    | _ -> raise Bad_Arg
;;

let ae_prop args=
  match args with
      [Move str_pos] -> (Board.set_stones [(Board.Empty, pos_of_sgf_coord str_pos)])
    | _ -> raise Bad_Arg
;;



let avail_properties = [
  ("AB", ab_prop);
  ("AW", ab_prop);
  ("AE", ae_prop);
  ("GM", gm_prop);
  ("FF", ff_prop);
  ("SZ", sz_prop);
  ("B", b_prop);
  ("W", w_prop)
]

(***********************************************************
 * Node processing functions
***********************************************************)
let do_prop (name, args)=
  try
    let (_, prop_fn) = List.find (fun (n, fn) ->
				    if String.compare name n=0 then
				      true
				    else
				      false) avail_properties 
    in
      prop_fn args
  with
      Not_found -> ()
;;

(* 'executes' the properties of a node 
   this should also result in 1 move placed on the Board undo stack
*)
let do_node node=
  let Node( prop_list) = node in
    List.iter do_prop prop_list

;;

(* Returns the internal represention of the sgf file at filename
   This function is external to the sgfTree class for two reasons
   1) It doesn't have an explicit dependence on any of sgfTree's internal data
   2) It makes testing this functionality much easier

   SgfParser and SgfLexer are autogenerated files from their respective mly and mll files
*)

let tree_of_sgf_file filename=
  let lexbuf = Lexing.from_string (string_of_file filename) in
    SgfParser.game_tree SgfLexer.parse_gametree lexbuf

(****************************************************************
 * This is the main class exported by this file
 * It is the main interface to an sgf file used throughout ergo
 ****************************************************************)

exception Tree_Empty;;

class sgfTree filename =
  let Tree( init_next, init_vars ) = tree_of_sgf_file filename in
object
  val mutable next_nodes = init_next
  val mutable variations = init_vars
    
  method next=
    let rec inner node_list vars =
      match node_list with
	  [] -> (
	    match vars with
		[] -> raise Tree_Empty
	      | Tree(nodes, v)::t ->
		  inner nodes v
	  )
	| h::t -> (
	    do_node h;
	    (* I need to put the node on the move_stack... *)
	    next_nodes <- t
	  )
    in
      inner next_nodes variations
end;;

(***************************************************************
 * Exported test suite
*****************************************************************)
let get_test_suite()=
  "SGF Tests" >:::
    [("File load" >:: fun _ ->
	assert_bool "1" ((String.compare (string_of_file "test/test1.sgf")
			    "(;GM[1]FF[4]SZ[9]HA[0])")=0)
     );
     (* These won't compile now... I think I should move them over to the sgfTree class somehow 
        They are valid tests afterall *)
     ("Tree creation" >:: fun _ ->
	assert_bool "test/test1.sgf" (
	   try
	     Tree ( [Node([("GM", [Number 1]); 
			   ("FF", [Number 4]);
			   ("SZ", [Number 9]); 
			   ("HA", [Number 0])
			  ])
		    ], [])=
	     tree_of_sgf_file "test/test1.sgf"
	   with
	       e -> false
	 );
	 assert_bool "test/test2.sgf" (
	   try
	     Tree ( [Node([("GM", [Number 1]);
			   ("FF", [Number 4]);
			   ("SZ", [Number 9]);
			   ("HA", [Number 0])]);
		     Node([("B", [Move "ee"])]);
		     Node([("W", [Move "ec"])]);
		     Node([("B", [Move "eg"])])],
		    []) =
	     tree_of_sgf_file "test/test2.sgf"
	   with 
	       e -> false
	 );
	 assert_bool "test/test3.sgf" (
	   try
	     Tree ( [Node([("GM", [Number 1]);
			   ("FF", [Number 4]);
			   ("SZ", [Number 9]);
			   ("HA", [Number 0])]);
		     Node([("B", [Move "ee"])]);
		     Node([("W", [Move "ec"])]);
		     Node([("B", [Move "eg"])])],
		    [Tree ([Node([("W", [Move "ce"])]);
			    Node([("B", [Move "ge"])])], []);
		     Tree ([Node([("W", [Move "ge"])]);
			    Node([("B", [Move "ce"])])], [])
		    ]) =
	     tree_of_sgf_file "test/test3.sgf"
	   with 
	       e -> false
	 )
     );
     ("sgfTree external tests" >:: fun _ -> (
	assert_bool "test/test1.sgf" (
	  let test_sgf = new sgfTree "test/test1.sgf" in
	    test_sgf#next;
	    try
	      test_sgf#next; false
	    with
		Tree_Empty -> if(Board.size() = 9) then true else false
	);
	assert_bool "test/test2.sgf" (
	  let test_sgf = new sgfTree "test/test2.sgf" in
	    test_sgf#next;
	    test_sgf#next;
	    assert_bool "test2 move 1" ((Board.get_status (Board.pos_of_string "e5")) = Board.Black);
	    test_sgf#next;
	    assert_bool "test2 move 2" ((Board.get_status (Board.pos_of_string "e7")) = Board.White);
	    test_sgf#next;
	    assert_bool "test2 move 3" ((Board.get_status (Board.pos_of_string "e3")) = Board.Black);
	    try
	      test_sgf#next; false
	    with
		Tree_Empty -> true
	)
      )
     )
       
       
    ]
;;
